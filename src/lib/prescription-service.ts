'use client';

import {
  collection,
  addDoc,
  serverTimestamp,
  query,
  where,
  onSnapshot,
  orderBy,
  DocumentData,
  doc,
  updateDoc,
  arrayUnion,
  Timestamp,
  getDocs,
} from 'firebase/firestore';
import { db } from './firebase';
import type { PrescriptionReaderOutput } from '@/ai/flows/prescription-reader';
import { Medication } from './user-service';
import { createNotification } from './notification-service';


export interface Prescription extends DocumentData {
  id: string;
  createdAt: Timestamp;
  doctorId: string;
  doctorName: string;
  followUp?: string;
  instructions?: string;
  medications: Medication[];
  patientId: string;
  patientName: string;
}


// Fetches prescriptions from the top-level 'prescriptions' collection
export const getPrescriptions = (
  uid: string,
  callback: (prescriptions: Prescription[]) => void
) => {
  const q = query(
    collection(db, 'prescriptions'),
    where('patientId', '==', uid),
    orderBy('createdAt', 'desc')
  );

  // This snapshot listener will now also trigger notifications for new e-prescriptions.
  const unsubscribe = onSnapshot(
    q,
    async (querySnapshot) => {
       const prescriptions: Prescription[] = [];
      
      const qOld = query(collection(db, 'prescriptions'), where('patientId', '==', uid));
      const oldSnapshot = await getDocs(qOld);
      const oldIds = new Set(oldSnapshot.docs.map(d => d.id));

      for (const doc of querySnapshot.docs) {
        prescriptions.push({ id: doc.id, ...doc.data() } as Prescription);
        // If the prescription is new, create a notification
        if (!oldIds.has(doc.id)) {
            const prescriptionData = doc.data() as Prescription;
            await createNotification(uid, {
                title: 'New E-Prescription Received',
                description: `You have a new prescription from Dr. ${prescriptionData.doctorName}.`,
                type: 'medicine'
            });
        }
      }
      callback(prescriptions);
    },
    (error) => {
      console.error('Error fetching prescriptions:', error);
      callback([]);
    }
  );

  return unsubscribe;
};

// This function saves a scanned prescription into the user's document,
// which is separate from the e-prescriptions generated by doctors.
// This could be refactored to also write to the main 'prescriptions' collection if needed.
export const saveScannedPrescription = async (
  uid: string,
  data: PrescriptionReaderOutput
): Promise<void> => {
  if (!uid || !data) {
    throw new Error('User ID and prescription data are required.');
  }

  const newPrescription = {
    id: `scan_${Date.now()}`,
    date: data.date, // Note: The doctor-generated prescriptions use a Timestamp.
    doctorName: data.doctorName,
    medications: data.medicines.map(med => ({
      name: med.name,
      dosage: med.dosage,
      frequency: med.frequency,
      duration: med.duration,
    })),
  };

  const userDocRef = doc(db, 'users', uid);
  
  await updateDoc(userDocRef, {
    pastPrescriptions: arrayUnion(newPrescription)
  });
};
